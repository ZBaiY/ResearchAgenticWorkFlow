#!/usr/bin/env python3
import argparse
import json
import os
import re
import subprocess
import sys
import time
import traceback
from datetime import datetime, timezone
from json import JSONDecodeError
from pathlib import Path
from typing import Any, Dict, List, Tuple


def now_utc() -> str:
    return datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")


def utc_compact() -> str:
    return datetime.now(timezone.utc).strftime("%Y%m%dT%H%M%SZ")


def repo_root() -> Path:
    return Path(__file__).resolve().parent.parent


def agents_root(root: Path) -> Path:
    return root / "AGENTS"


def skills_dir(root: Path) -> Path:
    return agents_root(root) / "skills"


def tasks_dir(root: Path) -> Path:
    return agents_root(root) / "tasks"


def runtime_dir(root: Path) -> Path:
    return agents_root(root) / "runtime"


def index_path(root: Path) -> Path:
    return runtime_dir(root) / "skills_index.json"


def run_cmd(cmd: List[str], cwd: Path) -> subprocess.CompletedProcess:
    return subprocess.run(cmd, cwd=str(cwd), text=True, capture_output=True)


def env_truthy(name: str, default: bool = False) -> bool:
    raw = os.environ.get(name)
    if raw is None:
        return default
    return raw.strip().lower() in {"1", "true", "yes", "y", "on"}


class NonInteractivePromptError(RuntimeError):
    pass


class SkillSubprocessError(RuntimeError):
    def __init__(self, skill: str, returncode: int, stdout: str, stderr: str):
        super().__init__(f"Skill '{skill}' failed with exit code {returncode}")
        self.skill = skill
        self.returncode = returncode
        self.stdout = stdout
        self.stderr = stderr


def strip_quotes(s: str) -> str:
    s = s.strip()
    if len(s) >= 2 and ((s[0] == '"' and s[-1] == '"') or (s[0] == "'" and s[-1] == "'")):
        return s[1:-1]
    return s


def parse_skill_yaml(path: Path) -> Tuple[Dict[str, Any], List[str]]:
    warnings: List[str] = []
    data: Dict[str, Any] = {
        "name": "",
        "title": "",
        "description": "",
        "run": "scripts/run.sh",
        "prompt": "prompts/prompt.md",
        "schema": "schemas/schema.json",
        "keywords": [],
        "outputs": [],
        "requires_network": False,
        "preferred_runner": [],
        "risk": "medium",
        "confirmations": [],
        "clarification_policy": "auto",
    }
    if not path.exists():
        warnings.append("missing skill.yaml")
        return data, warnings

    lines = path.read_text(encoding="utf-8").splitlines()
    i = 0
    while i < len(lines):
        raw = lines[i]
        i += 1
        if not raw.strip() or raw.lstrip().startswith("#"):
            continue
        m = re.match(r"^([A-Za-z_][A-Za-z0-9_]*):\s*(.*)$", raw)
        if not m:
            continue
        key, val = m.group(1), m.group(2).strip()
        if key in {"name", "title", "description", "risk", "clarification_policy", "run", "prompt", "schema"}:
            data[key] = strip_quotes(val)
        elif key == "requires_network":
            data[key] = val.lower() == "true"
        elif key in {"keywords", "preferred_runner", "confirmations"}:
            items: List[str] = []
            while i < len(lines):
                l = lines[i]
                if re.match(r"^\s{2,}-\s+", l):
                    item = re.sub(r"^\s{2,}-\s+", "", l).strip()
                    items.append(strip_quotes(item))
                    i += 1
                else:
                    break
            data[key] = items
        elif key == "outputs":
            items: List[Dict[str, str]] = []
            while i < len(lines):
                l = lines[i]
                if re.match(r"^\s{2,}-\s+", l):
                    item = re.sub(r"^\s{2,}-\s+", "", l).strip()
                    if ":" in item:
                        k, v = item.split(":", 1)
                        items.append({k.strip(): strip_quotes(v.strip())})
                    i += 1
                else:
                    break
            data["outputs"] = items

    if not data.get("name"):
        warnings.append("skill.yaml missing name")
    if not data.get("description"):
        warnings.append("skill.yaml missing description")
    if not isinstance(data.get("keywords"), list):
        warnings.append("skill.yaml keywords malformed")
        data["keywords"] = []
    if data.get("run") != "scripts/run.sh":
        warnings.append("skill.yaml run must be scripts/run.sh")
    return data, warnings


def build_index(root: Path) -> Dict[str, Any]:
    sdir = skills_dir(root)
    idx: Dict[str, Any] = {
        "generated_at_utc": now_utc(),
        "repo_root": str(root),
        "skills": [],
        "warnings": [],
    }
    for p in sorted(sdir.iterdir()):
        if not p.is_dir():
            continue
        name = p.name
        sy = p / "skill.yaml"
        meta, warns = parse_skill_yaml(sy)
        prompt_rel = str(meta.get("prompt", "prompts/prompt.md"))
        run_rel = str(meta.get("run", "scripts/run.sh"))
        schema_rel = str(meta.get("schema", "schemas/schema.json"))
        prompt = p / prompt_rel
        runsh = p / run_rel
        schema = p / schema_rel
        degraded = not sy.exists() or len(warns) > 0
        if degraded:
            desc = ""
            if prompt.exists():
                for line in prompt.read_text(encoding="utf-8").splitlines():
                    t = line.strip()
                    if t and not t.startswith("#"):
                        desc = t
                        break
            if not meta.get("name"):
                meta["name"] = name
            if not meta.get("title"):
                meta["title"] = name
            if not meta.get("description"):
                meta["description"] = desc or "No description available"

        rec = {
            "name": name,
            "path": str(p.relative_to(root)),
            "title": meta.get("title", name),
            "description": meta.get("description", ""),
            "run": run_rel,
            "prompt": prompt_rel,
            "schema": schema_rel,
            "keywords": meta.get("keywords", []),
            "outputs": meta.get("outputs", []),
            "requires_network": bool(meta.get("requires_network", False)),
            "preferred_runner": meta.get("preferred_runner", []),
            "risk": meta.get("risk", "medium"),
            "confirmations": meta.get("confirmations", []),
            "clarification_policy": meta.get("clarification_policy", "auto"),
            "has_run_sh": runsh.exists(),
            "has_prompt_md": prompt.exists(),
            "has_schema": schema.exists(),
            "degraded": degraded,
            "warnings": warns,
        }
        idx["skills"].append(rec)
        for w in warns:
            idx["warnings"].append(f"{name}: {w}")

    runtime_dir(root).mkdir(parents=True, exist_ok=True)
    index_path(root).write_text(json.dumps(idx, indent=2), encoding="utf-8")
    return idx


def ensure_index(root: Path) -> Dict[str, Any]:
    ip = index_path(root)
    if not ip.exists():
        return build_index(root)
    return json.loads(ip.read_text(encoding="utf-8"))


def tokenize(text: str) -> List[str]:
    return re.findall(r"[a-z0-9_+-]+", text.lower())


def score_skill(skill: Dict[str, Any], query: str) -> int:
    qtokens = tokenize(query)
    fields = " ".join(
        [
            skill.get("name", ""),
            skill.get("title", ""),
            skill.get("description", ""),
            " ".join(skill.get("keywords", []) or []),
        ]
    ).lower()
    score = 0
    for t in qtokens:
        if t in fields:
            score += 1
    if skill.get("name", "") in query.lower():
        score += 3
    return score


def cmd_index(root: Path) -> int:
    idx = build_index(root)
    print(f"INDEX={index_path(root)} SKILLS={len(idx.get('skills', []))} WARNINGS={len(idx.get('warnings', []))}")
    for w in idx.get("warnings", []):
        print(f"WARN={w}")
    return 0


def fmt_outputs(outputs: List[Dict[str, str]]) -> str:
    if not outputs:
        return "NONE"
    parts = []
    for item in outputs:
        for k, v in item.items():
            parts.append(f"{k}:{v}")
    return " | ".join(parts)


def cmd_suggest(root: Path, text: str) -> int:
    idx = ensure_index(root)
    skills = idx.get("skills", [])
    ranked = sorted(skills, key=lambda s: (-score_skill(s, text), s.get("name", "")))
    top = ranked[:5]

    for s in top:
        print(
            "CARD="
            f"SKILL={s.get('name')} "
            f"DESC={s.get('description','').replace(' ', '_')} "
            f"RISK={s.get('risk','medium')} "
            f"NETWORK={str(bool(s.get('requires_network', False))).lower()} "
            f"OUTPUTS={fmt_outputs(s.get('outputs', [])).replace(' ', '_')}"
        )

    if not top:
        print("RECOMMENDED=NONE")
        return 0

    s0 = score_skill(top[0], text)
    ties = [s for s in ranked if score_skill(s, text) == s0 and s0 > 0]
    if len(ties) == 1:
        print(f"RECOMMENDED={top[0].get('name')}")
    else:
        print("RECOMMENDED=NONE")
    return 0


def git_head(root: Path) -> str:
    cp = run_cmd(["git", "rev-parse", "HEAD"], root)
    if cp.returncode != 0:
        return ""
    return cp.stdout.strip()


def write_request(task_dir: Path, args: argparse.Namespace) -> str:
    req_path = task_dir / "request.md"
    if args.request == "-":
        content = sys.stdin.read()
        req_path.write_text(content, encoding="utf-8")
        return "stdin"
    if args.request and args.request != "?":
        src = Path(args.request).expanduser()
        if not src.is_absolute():
            src = (repo_root() / src).resolve()
        if src.exists():
            content = src.read_text(encoding="utf-8")
        else:
            src.parent.mkdir(parents=True, exist_ok=True)
            content = (
                "# Request\n\n"
                "Goal:\n"
                "TBD\n\n"
                "Background:\n"
                "TBD\n\n"
                "Constraints:\n"
                "- TBD\n\n"
                "Deliverables:\n"
                "- TBD\n"
            )
            src.write_text(content, encoding="utf-8")
        req_path.write_text(content, encoding="utf-8")
        return f"request:{src}"
    if args.request_file:
        src = Path(args.request_file).expanduser().resolve()
        content = src.read_text(encoding="utf-8")
        req_path.write_text(content, encoding="utf-8")
        return f"file:{src}"
    if args.edit:
        if not req_path.exists() or not req_path.read_text(encoding="utf-8").strip():
            req_path.write_text(
                "# Request\n\nGoal:\nTBD\n\nConstraints:\n- TBD\n\nInputs:\n- TBD\n",
                encoding="utf-8",
            )
        editor = os.environ.get("EDITOR", "vim")
        subprocess.run([editor, str(req_path)], check=False)
        return f"editor:{editor}"

    req_path.write_text(
        "# Request\n\nGoal:\nTBD\n\nBackground:\nTBD\n\nConstraints:\n- TBD\n\nDeliverables:\n- TBD\n",
        encoding="utf-8",
    )
    editor = os.environ.get("EDITOR", "vim")
    subprocess.run([editor, str(req_path)], check=False)
    return f"template+editor:{editor}"


def validate_task_name(name: str) -> bool:
    return bool(re.fullmatch(r"[A-Za-z0-9_]+", name))


def default_task_name(skill: str) -> str:
    return f"{skill}_{utc_compact()}"


def reserve_task_id(root: Path, skill: str) -> str:
    # Ensure uniqueness while preserving the <skill>_<timestamp> format.
    while True:
        candidate = default_task_name(skill)
        if not (tasks_dir(root) / candidate).exists():
            return candidate
        time.sleep(1)


def init_task_dir(root: Path, task_id: str) -> Path:
    tdir = tasks_dir(root) / task_id
    tdir.mkdir(parents=True, exist_ok=False)
    (tdir / "work").mkdir(parents=True, exist_ok=True)
    (tdir / "outputs" / "fig").mkdir(parents=True, exist_ok=True)
    (tdir / "outputs" / "tables").mkdir(parents=True, exist_ok=True)
    (tdir / "logs").mkdir(parents=True, exist_ok=True)
    (tdir / "review").mkdir(parents=True, exist_ok=True)
    (tdir / "deliverable").mkdir(parents=True, exist_ok=True)
    (tdir / "plan.md").write_text("# plan.md\n# Agent plan (to be filled by agent)\n", encoding="utf-8")
    return tdir


def cmd_start(root: Path, args: argparse.Namespace) -> int:
    if args.task_name:
        if not validate_task_name(args.task_name):
            print("ERROR=Invalid --task-name. Use only letters, digits, and underscores.", file=sys.stderr)
            return 2
        task_id = args.task_name
        if (tasks_dir(root) / task_id).exists():
            print(f"ERROR=Task already exists: {task_id}", file=sys.stderr)
            return 2
    else:
        task_id = reserve_task_id(root, args.skill)

    tdir = init_task_dir(root, task_id)

    source = write_request(tdir, args)

    meta = {
        "task_id": task_id,
        "skill": args.skill,
        "created_at_utc": now_utc(),
        "request_source": source,
        "repo_root": str(root),
        "git_head": git_head(root),
    }
    (tdir / "meta.json").write_text(json.dumps(meta, indent=2), encoding="utf-8")

    print(f"TASK={task_id} REQUEST=AGENTS/tasks/{task_id}/request.md")
    return 0


def load_skill_from_index(idx: Dict[str, Any], skill: str) -> Dict[str, Any]:
    for s in idx.get("skills", []):
        if s.get("name") == skill:
            return s
    return {}


def infer_skill(root: Path, task_id: str) -> str:
    meta = tasks_dir(root) / task_id / "meta.json"
    if meta.exists():
        try:
            m = json.loads(meta.read_text(encoding="utf-8"))
            s = m.get("skill", "")
            if s:
                return s
        except Exception:
            return ""
    return ""


def skill_clarification_policy(root: Path, skill: str, smeta: Dict[str, Any]) -> str:
    p = str(smeta.get("clarification_policy", "")).strip().lower()
    if p in {"ask_user", "auto"}:
        return p
    meta, _ = parse_skill_yaml(skills_dir(root) / skill / "skill.yaml")
    p2 = str(meta.get("clarification_policy", "auto")).strip().lower()
    if p2 in {"ask_user", "auto"}:
        return p2
    return "auto"


def resolve_output_paths(root: Path, task_id: str, skill_meta: Dict[str, Any], skill: str) -> Tuple[str, str, str, str]:
    patch = "NONE"
    report = "NONE"
    result = "NONE"
    staged = ""
    outputs = skill_meta.get("outputs", []) or []
    for item in outputs:
        if "patch" in item:
            p = item["patch"].replace("<task_id>", task_id)
            path = root / p
            patch = p if path.exists() else "NONE"
        if "review" in item:
            p = item["review"].replace("<task_id>", task_id)
            if p.endswith("..."):
                rdir = root / p[:-3]
                if rdir.exists():
                    matches = sorted([x for x in rdir.glob("*.md")])
                    if matches:
                        report = str(matches[0].relative_to(root))
                continue
            path = root / p
            report = p if path.exists() else "NONE"

    if patch == "NONE":
        p = f"AGENTS/tasks/{task_id}/deliverable/patchset/patch.diff"
        if (root / p).exists():
            patch = p
    if report == "NONE":
        rdir = root / f"AGENTS/tasks/{task_id}/review"
        if rdir.exists():
            files = sorted(rdir.glob("*.md"))
            if files:
                report = str(files[0].relative_to(root))
    compute_result = f"AGENTS/tasks/{task_id}/outputs/compute/result.json"
    lit_candidates = f"AGENTS/tasks/{task_id}/outputs/lit/raw_candidates.jsonl"
    if (root / compute_result).exists():
        result = compute_result
    elif (root / lit_candidates).exists():
        result = lit_candidates
    stage_dir = f"GATE/staged/{task_id}/{skill}"
    if (root / stage_dir).exists():
        staged = stage_dir
    return patch, report, result, staged


def stderr_tail(text: str, max_lines: int = 8) -> str:
    lines = [x for x in text.splitlines() if x.strip()]
    if not lines:
        return ""
    return "\n".join(lines[-max_lines:])


def classify_error(err: Exception, phase: str, stderr_hint: str = "") -> Tuple[str, str]:
    if isinstance(err, NonInteractivePromptError):
        return "Non-interactive shell requires explicit approval mode.", "Run with --yes or --no."
    if isinstance(err, FileNotFoundError):
        return "Missing file or path.", "Input path is wrong or working directory is incorrect."
    if isinstance(err, JSONDecodeError):
        return "Malformed JSON content.", "A config/request file has invalid JSON syntax."
    if isinstance(err, PermissionError):
        return "Permission denied.", "File permissions or sandbox restrictions blocked access."
    if isinstance(err, SkillSubprocessError):
        tail = stderr_tail(stderr_hint or err.stderr)
        if "not found" in tail.lower() or "command not found" in tail.lower():
            return "Subprocess failed: required tool is missing.", "Install the missing binary and retry."
        return "Subprocess exited non-zero.", "Skill command failed; inspect stderr and skill logs."
    msg = str(err).lower()
    if "http" in msg or "url" in msg or "network" in msg or "rate limit" in msg or "unauthorized" in msg:
        return "Network/API request failed.", "Network issue, rate limit, or authentication problem."
    if "yaml" in msg and "parse" in msg:
        return "YAML parse failed.", "Malformed YAML in configuration/request."
    return "Unknown runtime failure.", "Unknown root cause."


def traceback_where(err: Exception) -> str:
    tb = traceback.extract_tb(err.__traceback__) if err.__traceback__ else []
    if not tb:
        return "unknown"
    top = tb[-3:]
    return " | ".join([f"{Path(f.filename).name}:{f.lineno} in {f.name}" for f in top])


def write_error_report(root: Path, task_id: str, phase: str, err: Exception, stderr_hint: str = "") -> str:
    review_dir = tasks_dir(root) / task_id / "review"
    review_dir.mkdir(parents=True, exist_ok=True)
    out = review_dir / "error.md"

    likely, guess_default = classify_error(err, phase, stderr_hint=stderr_hint)
    likely_cause = likely
    if isinstance(err, SkillSubprocessError):
        likely_cause = f"{likely_cause}\nstderr_tail:\n{stderr_tail(stderr_hint or err.stderr) or '(none)'}"
    if guess_default == "Unknown root cause.":
        unknown_guess = "HYPOTHESIS: check request.md and skill-specific logs for the first failing command."
    else:
        unknown_guess = "N/A"

    trace = "".join(traceback.format_exception(type(err), err, err.__traceback__))
    next_step = f"Inspect AGENTS/tasks/{task_id}/logs and AGENTS/tasks/{task_id}/request.md."
    if isinstance(err, NonInteractivePromptError):
        next_step = f"Re-run: ./bin/agenthub run --task {task_id} --yes"

    content = (
        "# Error Report\n\n"
        f"ERROR_CLASS: {err.__class__.__name__}\n\n"
        f"ERROR_MESSAGE: {str(err)}\n\n"
        f"WHERE: {traceback_where(err)}\n\n"
        f"PHASE: {phase}\n\n"
        f"LIKELY_CAUSE: {likely_cause}\n\n"
        f"IF_UNKNOWN_GUESS: {unknown_guess}\n\n"
        f"NEXT_STEP: {next_step}\n\n"
        "FULL_TRACEBACK:\n"
        "```text\n"
        f"{trace}"
        "```\n"
    )
    out.write_text(content, encoding="utf-8")
    return str(out.relative_to(root))


def parse_missing_from_error_report(root: Path, report_path: str) -> str:
    p = root / report_path
    if not p.exists():
        return ""
    try:
        text = p.read_text(encoding="utf-8", errors="ignore")
    except Exception:
        return ""
    m = re.search(r"^missing:\s*(.+)$", text, flags=re.M | re.I)
    if m:
        val = m.group(1).strip()
        if val in {"[]", '[""]', ""}:
            return ""
        return val
    m2 = re.search(r"^MISSING=([^\n]+)$", text, flags=re.M)
    if m2:
        return m2.group(1).strip()
    return ""


def parse_detail_lines_from_error_report(root: Path, report_path: str) -> List[str]:
    p = root / report_path
    if not p.exists():
        return []
    try:
        text = p.read_text(encoding="utf-8", errors="ignore")
    except Exception:
        return []
    details: List[str] = []
    for key in ["error_code", "completeness_rules", "online_lookup", "stop_reason"]:
        m = re.search(rf"^{key}:\s*(.+)$", text, flags=re.M | re.I)
        if m:
            details.append(f"{key}: {m.group(1).strip()}")
    m_next = re.search(r"^next_actions:\s*$([\s\S]+)", text, flags=re.M)
    if m_next:
        after = m_next.group(1).splitlines()
        for ln in after:
            s = ln.strip()
            if s.startswith("- "):
                details.append(f"next_action: {s[2:].strip()}")
                break
    return details[:6]


def stage_task_outputs(root: Path, task_id: str, skill: str, stage_enabled: bool) -> str:
    env = os.environ.copy()
    env["AGENTHUB_STAGE_APPROVAL"] = "yes" if stage_enabled else "no"
    cp = subprocess.run(
        [str(root / "AGENTS" / "runtime" / "stage_to_gate.sh"), str(root), task_id, skill],
        cwd=str(root),
        env=env,
        text=True,
        capture_output=True,
    )
    if cp.returncode != 0:
        msg = (cp.stderr or cp.stdout or "").strip() or "stage_to_gate failed"
        raise RuntimeError(f"STAGE_TO_GATE_FAILED: {msg}")
    stage_dir = root / "GATE" / "staged" / task_id / skill
    return str(stage_dir.relative_to(root)) if stage_dir.exists() else ""


def promotion_actions_for_stage(root: Path, task_id: str, skill: str) -> List[Tuple[Path, Path, str]]:
    staged = root / "GATE" / "staged" / task_id / skill
    if not staged.exists():
        return []
    actions: List[Tuple[Path, Path, str]] = []
    profile_json = staged / "paper_profile.json"
    if profile_json.exists():
        actions.append((profile_json, root / "USER" / "paper" / "meta" / "paper_profile.json", "file"))
    refs_bib = staged / "review" / "refs.bib"
    if refs_bib.exists():
        actions.append((refs_bib, root / "USER" / "paper" / "bib" / f"{task_id}.refs.bib", "file"))
    src_dir = staged / "deliverable" / "src"
    if src_dir.exists():
        actions.append((src_dir, root / "USER" / "src" / "compute" / task_id, "dir"))
    slides_dir = staged / "deliverable" / "slides"
    if slides_dir.exists():
        actions.append((slides_dir, root / "USER" / "presentations" / task_id, "dir"))
    return actions


def write_promotion_preview(root: Path, task_id: str, skill: str) -> Tuple[str, str]:
    staged_root = root / "GATE" / "staged" / task_id
    staged_skill = staged_root / skill
    preview = staged_root / "PROMOTE.md"
    next_cmd = f"./bin/agenthub promote --task {task_id}"

    actions = promotion_actions_for_stage(root, task_id, skill) if staged_skill.exists() else []
    lines = [
        "# Prepare To Promote",
        "",
        f"- task_id: {task_id}",
        f"- skill: {skill}",
        f"- staged_dir: GATE/staged/{task_id}/{skill}",
        "",
        "PROMOTION_STATUS=READY",
        f"NEXT_PROMOTE_CMD={next_cmd}",
        f"PROMOTE_PREVIEW_PATH=GATE/staged/{task_id}/PROMOTE.md",
        "",
        "## File Mapping (GATE -> USER)",
    ]
    if actions:
        for src, dst, _ in actions:
            try:
                src_rel = str(src.relative_to(root))
            except Exception:
                src_rel = str(src)
            try:
                dst_rel = str(dst.relative_to(root))
            except Exception:
                dst_rel = str(dst)
            lines.append(f"- {src_rel} -> {dst_rel}")
    else:
        lines.append("- (no known mappings discovered for this skill)")
    lines += [
        "",
        "## Command",
        f"- {next_cmd}",
        "",
        'Warning: Promotion requires explicit user confirmation. The workflow is paused.',
        "",
    ]
    staged_root.mkdir(parents=True, exist_ok=True)
    preview.write_text("\n".join(lines), encoding="utf-8")
    return str(preview.relative_to(root)), next_cmd


def print_error_summary(root: Path, err: Exception, report_path: str) -> None:
    short = str(err).strip().splitlines()[0] if str(err).strip() else err.__class__.__name__
    if len(short) > 140:
        short = short[:137] + "..."
    if isinstance(err, SkillSubprocessError):
        short = f"{err.skill} exited non-zero (exit code {err.returncode})"
    print(f"ERROR={short}", file=sys.stderr)
    print(f"SEE={report_path}", file=sys.stderr)
    missing = parse_missing_from_error_report(root, report_path)
    if missing:
        print(f"MISSING={missing}", file=sys.stderr)
    print("EXIT=nonzero", file=sys.stderr)


def prompt_yes_no_fuzzy_tty(prompt: str) -> Tuple[bool, bool]:
    try:
        with open("/dev/tty", "r+", encoding="utf-8") as tty:
            tty.write(prompt)
            tty.flush()
            ans = tty.readline().strip().lower()
            if ans in {"yes", "y", "yeah", "ok", "sure", "1", "promote"}:
                return True, False
            if ans in {"no", "n", "stop", "0", "cancel", ""}:
                return False, False
            tty.write(prompt)
            tty.flush()
            ans2 = tty.readline().strip().lower()
            if ans2 in {"yes", "y", "yeah", "ok", "sure", "1", "promote"}:
                return True, False
            return False, False
    except Exception:
        try:
            ans = input(prompt).strip().lower()
        except EOFError:
            return False, True
        if ans in {"yes", "y", "yeah", "ok", "sure", "1", "promote"}:
            return True, False
        if ans in {"no", "n", "stop", "0", "cancel", ""}:
            return False, False
        try:
            ans2 = input(prompt).strip().lower()
        except EOFError:
            return False, True
        if ans2 in {"yes", "y", "yeah", "ok", "sure", "1", "promote"}:
            return True, False
        return False, False


def cmd_run(root: Path, args: argparse.Namespace) -> int:
    task_id = args.task
    phase = "run"
    try:
        idx = ensure_index(root)
        skill = args.skill or infer_skill(root, task_id)
        if not skill:
            raise RuntimeError("Missing skill. Provide --skill or set skill in AGENTS/tasks/<task_id>/meta.json")

        smeta = load_skill_from_index(idx, skill)
        if not smeta:
            meta, _ = parse_skill_yaml(skills_dir(root) / skill / "skill.yaml")
            smeta = {"name": skill, "run": meta.get("run", "scripts/run.sh")}
        run_rel = str(smeta.get("run", "scripts/run.sh")).strip()
        if run_rel != "scripts/run.sh":
            raise RuntimeError(f"SKILL_ENTRYPOINT_INVALID skill={skill} run={run_rel} required=scripts/run.sh")

        if args.yes and args.no:
            raise RuntimeError("Use only one of --yes or --no.")
        if args.stage_gate and args.no_stage_gate:
            raise RuntimeError("Use only one of --stage-gate or --no-stage-gate.")

        interactive_tty = sys.stdin.isatty()
        agent_mode_on = bool(args.agent_mode or env_truthy("AGENT_MODE", False))
        auto_promote_user = bool(args.auto_promote_user or env_truthy("AUTO_PROMOTE_USER", False))
        if not agent_mode_on:
            auto_promote_user = False

        # Run is non-interactive by design; approval_mode defaults to "no"
        # unless explicitly set to --yes.
        approval_mode = "yes" if args.yes else "no"

        phase = "skill_run"
        env = os.environ.copy()
        env["APPROVAL_MODE"] = approval_mode
        env["APPROVAL_INTERACTIVE"] = "1" if interactive_tty else "0"
        env["ALLOW_USER_WRITE"] = "1" if args.write_user else "0"
        env["SKILL_CLARIFICATION_POLICY"] = skill_clarification_policy(root, skill, smeta)
        env["ONLINE_LOOKUP"] = "1" if args.online else "0"
        env["NET_ALLOWED"] = "1" if args.net else "0"
        cp = subprocess.run(
            [str(root / "bin" / "agentctl"), "run", skill, "--task", task_id],
            cwd=str(root),
            env=env,
            text=True,
            capture_output=True,
        )
        if cp.returncode != 0:
            if cp.stdout.strip():
                print(cp.stdout.strip())
            raise SkillSubprocessError(skill=skill, returncode=cp.returncode, stdout=cp.stdout, stderr=cp.stderr)
        if cp.stdout.strip():
            print(cp.stdout.strip())
        if cp.stderr.strip():
            print(cp.stderr.strip(), file=sys.stderr)

        phase = "stage"
        if args.no_stage_gate:
            print("NOTE=--no-stage-gate ignored; staging is mandatory on successful runs.")
        stage_enabled = True
        staged_dir = stage_task_outputs(root, task_id, skill, stage_enabled=stage_enabled)

        phase = "summary"
        patch, report, result, staged = resolve_output_paths(root, task_id, smeta, skill)
        if staged_dir:
            staged = staged_dir
        review_dir = f"AGENTS/tasks/{task_id}/review"

        print(f"TASK_ID: {task_id}")
        print(f"SKILL: {skill}")
        print(f"REVIEW_DIR_PATH: {review_dir if (root / review_dir).exists() else 'NONE'}")
        print(f"REPORT_PATH: {report}")
        print(f"OUTPUT_PATH: {result}")
        print(f"STAGED_DIR_PATH: {staged or 'NONE'}")
        print(f"AGENT_MODE={'on' if agent_mode_on else 'off'}")
        print(f"AUTO_PROMOTE_USER={'on' if auto_promote_user else 'off'}")

        phase = "promotion"
        preview_path, _next_cmd = write_promotion_preview(root, task_id, skill)
        print("PROMOTION_STATUS=READY")
        print(f"PROMOTE_PLAN_PATH: {preview_path}")
        print("PROMOTION_PENDING: true")
        print("PROMOTE_INSTRUCTIONS: Use the promote subcommand when ready.")
        return 0
    except Exception as err:
        skill_error = tasks_dir(root) / task_id / "review" / "error.md"
        if isinstance(err, SkillSubprocessError) and skill_error.exists():
            report = str(skill_error.relative_to(root))
        else:
            report = write_error_report(root, task_id, phase=phase, err=err, stderr_hint=getattr(err, "stderr", ""))
        print_error_summary(root, err, report)
        return 2


def cmd_promote(root: Path, args: argparse.Namespace) -> int:
    task_id = args.task
    staged_root = root / "GATE" / "staged" / task_id
    if not staged_root.exists():
        print(f"PROMOTE_TO_USER=blocked reason=missing_staged_task task={task_id}", file=sys.stderr)
        return 2

    interactive_tty = sys.stdin.isatty()
    if args.yes and args.no:
        print("ERROR=Use only one of --yes or --no.", file=sys.stderr)
        return 2
    if args.no:
        print("PROMOTE_TO_USER=skipped reason=user_declined")
        return 0

    confirmed_yes = bool(args.yes)
    if interactive_tty and not confirmed_yes:
        answer, interactive_error = prompt_yes_no_fuzzy_tty("PROMOTE_TO_USER? [y/N]")
        if interactive_error:
            print("PROMOTE_TO_USER=blocked reason=interactive_prompt_failed", file=sys.stderr)
            return 2
        if not answer:
            print("PROMOTE_TO_USER=skipped reason=user_declined")
            return 0
        confirmed_yes = True

    if not interactive_tty:
        if not (args.yes and args.allow_user_write_noninteractive):
            next_cmd = (
                f"./bin/agenthub promote --task {task_id} "
                "--yes --allow-user-write-noninteractive"
            )
            print(f"PROMOTE_TO_USER=skipped reason=noninteractive_requires_explicit_flags NEXT={next_cmd}")
            return 0

    cmd = ["bash", "AGENTS/runtime/promote_to_user.sh", "--task", task_id]
    if confirmed_yes:
        cmd.append("--yes")
    if not interactive_tty and args.allow_user_write_noninteractive:
        cmd.append("--allow-user-write-noninteractive")
    cp = subprocess.run(cmd, cwd=str(root), text=True, capture_output=True)
    if cp.returncode != 0:
        msg = (cp.stderr or cp.stdout or "promotion failed").strip()
        print(f"PROMOTE_TO_USER=blocked reason={msg}", file=sys.stderr)
        return 2
    targets = []
    receipt = ""
    for line in cp.stdout.splitlines():
        t = line.strip()
        if t.startswith("PROMOTED_TARGET="):
            targets.append(t.split("=", 1)[1].strip())
        if t.startswith("PROMOTION_RECEIPT="):
            receipt = t.split("=", 1)[1].strip()
    target = targets[0] if targets else "unknown"
    print(f"PROMOTE_TO_USER=done target={target}")
    if receipt:
        print(f"PROMOTION_RECEIPT={receipt}")
    return 0


def prompt_yes_no(prompt: str) -> Tuple[bool, bool]:
    try:
        ans = input(prompt).strip().lower()
    except EOFError:
        return False, True
    return ans in {"y", "yes"}, False


def prompt_yes_no_fuzzy(prompt: str) -> Tuple[bool, bool]:
    try:
        ans = input(prompt).strip().lower()
    except EOFError:
        return False, True
    if ans in {"yes", "y", "yeah", "ok", "sure", "1", "promote"}:
        return True, False
    if ans in {"no", "n", "stop", "0", "cancel", ""}:
        return False, False
    # ambiguous: ask once more, then default NO
    try:
        ans2 = input(prompt).strip().lower()
    except EOFError:
        return False, True
    if ans2 in {"yes", "y", "yeah", "ok", "sure", "1", "promote"}:
        return True, False
    return False, False


def cmd_doctor(root: Path) -> int:
    errors: List[str] = []
    checks = [
        root / "AGENTS" / "skills",
        root / "AGENTS" / "tasks",
        root / "USER",
        root / "GATE",
        root / "bin" / "agentctl",
    ]
    for p in checks:
        if not p.exists():
            errors.append(f"missing:{p.relative_to(root)}")

    agentctl = root / "bin" / "agentctl"
    if agentctl.exists() and not os.access(agentctl, os.X_OK):
        errors.append("agentctl_not_executable")

    sdir = skills_dir(root)
    if sdir.exists():
        for s in sorted(sdir.iterdir()):
            if not s.is_dir():
                continue
            if not (s / "scripts" / "run.sh").exists():
                errors.append(f"missing_run_sh:{s.relative_to(root)}/scripts/run.sh")
            if (s / "run.sh").exists() or (s / "prompt.md").exists() or (s / "schema.json").exists():
                errors.append(f"root_duplicate_files:{s.relative_to(root)}")
            meta, warns = parse_skill_yaml(s / "skill.yaml")
            if str(meta.get("run", "")).strip() != "scripts/run.sh":
                errors.append(f"invalid_runner_path:{s.relative_to(root)}/skill.yaml")

    if errors:
        for e in errors:
            print(f"ERROR={e}")
        return 1

    print("DOCTOR=ok")
    return 0


def main() -> int:
    root = repo_root()

    parser = argparse.ArgumentParser(prog="agenthub")
    sub = parser.add_subparsers(dest="cmd", required=True)

    sub.add_parser("index")

    ps = sub.add_parser("suggest")
    ps.add_argument("text")

    pstart = sub.add_parser("start")
    pstart.add_argument("--skill", required=True)
    pstart.add_argument("--task-name", default=None)
    pstart.add_argument("--request", default=None)
    pstart.add_argument("--request-file", default=None)
    pstart.add_argument("--edit", action="store_true")

    prun = sub.add_parser("run")
    prun.add_argument("--task", required=True)
    prun.add_argument("--skill", default=None)
    prun.add_argument("--yes", action="store_true")
    prun.add_argument("--no", action="store_true")
    prun.add_argument("--write-user", action="store_true")
    prun.add_argument("--online", action="store_true")
    prun.add_argument("--net", action="store_true")
    prun.add_argument("--stage-gate", action="store_true")
    prun.add_argument("--no-stage-gate", action="store_true")
    prun.add_argument("--agent-mode", action="store_true")
    prun.add_argument("--auto-promote-user", action="store_true")
    prun.add_argument("--allow-user-write-noninteractive", action="store_true")

    ppromote = sub.add_parser("promote")
    ppromote.add_argument("--task", required=True)
    ppromote.add_argument("--yes", action="store_true")
    ppromote.add_argument("--no", action="store_true")
    ppromote.add_argument("--allow-user-write-noninteractive", action="store_true")

    pname = sub.add_parser("task-name")
    pname.add_argument("--skill", required=True)

    sub.add_parser("doctor")

    args = parser.parse_args()

    if args.cmd == "index":
        return cmd_index(root)
    if args.cmd == "suggest":
        return cmd_suggest(root, args.text)
    if args.cmd == "start":
        return cmd_start(root, args)
    if args.cmd == "run":
        return cmd_run(root, args)
    if args.cmd == "promote":
        return cmd_promote(root, args)
    if args.cmd == "task-name":
        print(f"TASK_NAME={default_task_name(args.skill)}")
        return 0
    if args.cmd == "doctor":
        return cmd_doctor(root)

    return 2


if __name__ == "__main__":
    raise SystemExit(main())
