#!/usr/bin/env python3
import argparse
import json
import os
import re
import subprocess
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple

def repo_root() -> Path:
    return Path(__file__).resolve().parent.parent


def utc_compact() -> str:
    return datetime.now(timezone.utc).strftime("%Y%m%dT%H%M%SZ")


def run_checked(cmd: List[str], cwd: Path) -> subprocess.CompletedProcess:
    cp = subprocess.run(cmd, cwd=str(cwd), text=True, capture_output=True)
    if cp.returncode != 0:
        tail = (cp.stderr or cp.stdout or "").strip().splitlines()
        msg = tail[-1] if tail else f"command failed: {' '.join(cmd)}"
        raise RuntimeError(msg)
    return cp


def load_json(path: Path) -> Dict[str, Any]:
    return json.loads(path.read_text(encoding="utf-8"))


STOPWORDS: Set[str] = {
    "a",
    "an",
    "and",
    "as",
    "be",
    "can",
    "for",
    "from",
    "i",
    "in",
    "is",
    "it",
    "me",
    "my",
    "of",
    "on",
    "or",
    "please",
    "the",
    "to",
    "want",
    "with",
    "you",
}

TOKEN_NORMALIZATION = {
    "algebraically": "algebraic",
    "symbolically": "symbolic",
    "numerically": "numerical",
}

DOMAIN_KEYWORDS = {
    "compute_algebraic": [
        "algebraic",
        "symbolic",
        "simplify",
        "derive",
        "closed-form",
        "exact",
        "integrate",
        "differentiate",
        "series",
        "solve",
        "assumptions",
        "latex",
    ],
    "compute_numerical": [
        "numerical",
        "simulate",
        "approximate",
        "monte-carlo",
        "ode",
        "pde",
        "optimize",
        "fit",
        "plot",
        "sample",
        "benchmark",
        "precision",
        "tolerance",
    ],
    "compute_algebraic_multistep": [
        "algebraic",
        "symbolic",
        "multistep",
        "plan",
        "review",
        "execute",
        "mathematica",
        "wolfram",
        "derive",
        "simplify",
    ],
}


def normalize_text(text: str) -> str:
    lowered = text.lower()
    cleaned = re.sub(r"[^a-z0-9]+", " ", lowered)
    raw_tokens = [t for t in cleaned.split() if t]
    normalized = [TOKEN_NORMALIZATION.get(t, t) for t in raw_tokens]
    return " ".join(normalized)


def tokenize(text: str, *, drop_stopwords: bool = True) -> List[str]:
    normalized = normalize_text(text)
    tokens = [t for t in normalized.split() if t]
    if drop_stopwords:
        tokens = [t for t in tokens if t not in STOPWORDS]
    return tokens


def tokenize_skill_name(name: str) -> List[str]:
    parts = re.sub(r"([a-z0-9])([A-Z])", r"\1 \2", name).replace("_", " ").replace("-", " ")
    return tokenize(parts)


def query_matches_skill(skill: Dict[str, Any], query: str) -> List[str]:
    qtokens = tokenize(query)
    fields_tokens = set(tokenize(skill.get("title", ""), drop_stopwords=False))
    fields_tokens.update(tokenize(skill.get("description", ""), drop_stopwords=False))
    fields_tokens.update(tokenize(" ".join(skill.get("keywords", []) or []), drop_stopwords=False))
    fields_tokens.update(tokenize_skill_name(skill.get("name", "")))
    out: List[str] = []
    seen = set()
    for t in qtokens:
        if t in fields_tokens and t not in seen:
            out.append(t)
            seen.add(t)
    return out[:4]


def compute_base_score(skill: Dict[str, Any], query: str) -> Tuple[float, List[str]]:
    matches = query_matches_skill(skill, query)
    score = float(len(matches))
    name = skill.get("name", "").lower()
    if name and name in query.lower():
        score += 3.0
        if "skill_name" not in matches:
            matches.append("skill_name")
    return score, matches


def normalized_keyword_hits(skill_name: str, query: str) -> List[str]:
    qnorm = normalize_text(query)
    qtokens = set(tokenize(query))
    hits: List[str] = []
    for kw in DOMAIN_KEYWORDS.get(skill_name, []):
        kwnorm = normalize_text(kw)
        if not kwnorm:
            continue
        if " " in kwnorm:
            if kwnorm in qnorm:
                hits.append(kw)
            continue
        if kwnorm in qtokens:
            hits.append(kw)
    return hits[:6]


def apply_router_boosts(
    entries: Dict[str, Dict[str, Any]], query: str, router_cfg: Dict[str, Any]
) -> None:
    q = normalize_text(query)
    for rule in router_cfg.get("rules", []):
        skill = rule.get("skill", "")
        if skill not in entries:
            continue
        ent = entries[skill]
        any_keywords = [normalize_text(x) for x in rule.get("any_keywords", []) if isinstance(x, str)]
        all_keywords = [normalize_text(x) for x in rule.get("all_keywords", []) if isinstance(x, str)]
        negative_keywords = [
            normalize_text(x) for x in rule.get("negative_keywords", []) if isinstance(x, str)
        ]
        boost = float(rule.get("boost", 0.0))
        boost_all = float(rule.get("boost_all", boost))
        penalty = float(rule.get("penalty", boost))

        any_hits = [k for k in any_keywords if k in q]
        all_hits = [k for k in all_keywords if k in q]
        neg_hits = [k for k in negative_keywords if k in q]

        if any_hits:
            ent["score"] += boost
            ent["reasons"].extend([f"kw:{k}" for k in any_hits])
            ent["has_domain_signal"] = True
        if all_keywords and len(all_hits) == len(all_keywords):
            ent["score"] += boost_all
            ent["reasons"].extend([f"all:{k}" for k in all_hits])
            ent["has_domain_signal"] = True
        if neg_hits:
            ent["score"] -= penalty
            ent["reasons"].extend([f"neg:{k}" for k in neg_hits])


def build_ranking(root: Path, query: str) -> List[Dict[str, Any]]:
    idx_path = root / "AGENTS" / "runtime" / "skills_index.json"
    if not idx_path.exists():
        raise RuntimeError(
            "skills index missing: AGENTS/runtime/skills_index.json "
            "(run ./bin/agenthub index)"
        )
    idx = load_json(idx_path)
    router_cfg = load_json(root / "AGENTS" / "runtime" / "intent_router.json")
    skills = idx.get("skills", [])

    entries: Dict[str, Dict[str, Any]] = {}
    for s in skills:
        name = s.get("name", "")
        if not name:
            continue
        base_score, base_terms = compute_base_score(s, query)
        domain_hits = normalized_keyword_hits(name, query)
        domain_boost = float(len(domain_hits) * 15)
        entries[name] = {
            "name": name,
            "description": (s.get("description", "") or "").strip(),
            "base_score": base_score,
            "score": base_score + domain_boost,
            "reasons": [f"match:{x}" for x in base_terms] + [f"domain:{x}" for x in domain_hits],
            "has_domain_signal": bool(domain_hits),
        }

    apply_router_boosts(entries, query, router_cfg)
    ranked = list(entries.values())
    for rec in ranked:
        dedup = []
        seen = set()
        for x in rec.get("reasons", []):
            if x not in seen:
                dedup.append(x)
                seen.add(x)
        rec["reasons"] = dedup[:6]
    ranked.sort(key=lambda x: (-x["score"], x["name"]))
    return ranked


def decide_candidates(
    ranked: List[Dict[str, Any]], policy: Dict[str, Any], k_override: Optional[int]
) -> Dict[str, Any]:
    t_low = float(policy.get("T_low", 15))
    t_multi = float(policy.get("T_multi", 35))
    t_high = float(policy.get("T_high", 50))
    k_default = int(policy.get("K_default", 3))
    k_max = int(policy.get("K_max", 8))

    if not ranked:
        return {
            "recommended": "",
            "top1_score": 0.0,
            "mode": "LOWCONF",
            "warn_no_match": True,
            "candidates": [],
            "must_show": set(),
        }

    best = ranked[0]
    mode = "NORMAL"
    warn_no_match = False
    if best["score"] < t_low:
        if best.get("has_domain_signal"):
            mode = "MEDCONF"
        else:
            mode = "LOWCONF"
            warn_no_match = True
    elif best["score"] >= t_high:
        mode = "HIGHCONF"

    must_show_names = {r["name"] for r in ranked if r["score"] >= t_multi}
    k = k_override if k_override is not None else k_default
    k = max(1, min(k, k_max))

    selected: List[Dict[str, Any]] = []
    seen = set()

    # Always include top-1.
    for rec in ranked:
        if rec["name"] == best["name"]:
            selected.append(rec)
            seen.add(rec["name"])
            break

    # Fill top-K.
    for rec in ranked:
        if len(selected) >= k:
            break
        if rec["name"] in seen:
            continue
        selected.append(rec)
        seen.add(rec["name"])

    # Add MUST_SHOW candidates regardless of K.
    for rec in ranked:
        if rec["name"] in must_show_names and rec["name"] not in seen:
            selected.append(rec)
            seen.add(rec["name"])

    return {
        "recommended": best["name"],
        "top1_score": best["score"],
        "mode": mode,
        "warn_no_match": warn_no_match,
        "candidates": selected,
        "must_show": must_show_names,
    }


def parse_task_name(out: str) -> str:
    for line in out.splitlines():
        if line.startswith("TASK_NAME="):
            return line.split("=", 1)[1].strip()
    return ""


def parse_started_task(out: str) -> str:
    for line in out.splitlines():
        if line.startswith("TASK="):
            return line.split("=", 1)[1].split(" ", 1)[0].strip()
    return ""


def parse_marker(out: str, key: str) -> str:
    prefix = f"{key}="
    for line in out.splitlines():
        text = line.strip()
        if text.startswith(prefix):
            return text.split("=", 1)[1].strip()
    return ""


def is_compute_skill(skill: str) -> bool:
    return str(skill or "").startswith("compute_")


def parse_run_artifacts(out: str) -> Dict[str, str]:
    artifacts = {
        "report": "NONE",
        "result": "NONE",
        "patch": "NONE",
        "staged_dir": "NONE",
    }
    for line in out.splitlines():
        t = line.strip()
        if t.startswith("- Report:"):
            artifacts["report"] = t.split(":", 1)[1].strip() or "NONE"
        elif t.startswith("- Result:"):
            artifacts["result"] = t.split(":", 1)[1].strip() or "NONE"
        elif t.startswith("- Patch:"):
            artifacts["patch"] = t.split(":", 1)[1].strip() or "NONE"
        elif t.startswith("- Staged Dir:"):
            artifacts["staged_dir"] = t.split(":", 1)[1].strip() or "NONE"
    return artifacts


def collect_canonical_inputs(root: Path) -> List[str]:
    out: List[str] = []
    paper = root / "USER" / "paper"
    notes = root / "USER" / "notes"

    if paper.exists():
        for p in sorted(paper.rglob("*.tex")):
            if p.is_file():
                out.append(str(p.relative_to(root)))
    if notes.exists():
        for p in sorted(notes.rglob("*.md")):
            if p.is_file():
                out.append(str(p.relative_to(root)))
    return out


def write_request_template(
    root: Path, task_name: str, query: str, full_agent: bool, skill_name: Optional[str] = None
) -> str:
    req_dir = root / "AGENTS" / "requests"
    req_dir.mkdir(parents=True, exist_ok=True)
    req_path = req_dir / f"{task_name}.md"

    if full_agent:
        inputs = collect_canonical_inputs(root)
        if inputs:
            inputs_block = "\n".join(f"- {p}" for p in inputs)
        else:
            inputs_block = (
                "- USER/paper/**/*.tex (none found)\n"
                "- USER/notes/**/*.md (none found)"
            )
        content = (
            "# Request\n\n"
            "goal:\n"
            f"{query}\n\n"
            "constraints:\n"
            "- Do not modify USER; stage only to GATE; promotion is manual\n\n"
            "inputs:\n"
            f"{inputs_block}\n"
        )
    else:
        content = ""
        if skill_name:
            template_path = root / "AGENTS" / "skills" / skill_name / "templates" / "request.md"
            if template_path.exists():
                content = template_path.read_text(encoding="utf-8")
                content = content.replace("{{GOAL}}", query)
        if not content.strip():
            content = (
                "# Request\n\n"
                "Goal:\n"
                f"{query}\n\n"
                "Background:\n"
                "- Auto-generated from bart selection. Refine as needed.\n\n"
                "Constraints:\n"
                "- Do not modify USER/ unless explicitly requested.\n\n"
                "Deliverables:\n"
                "- A report under AGENTS/tasks/<task_id>/review/.\n"
            )

    req_path.write_text(content, encoding="utf-8")
    return str(req_path.relative_to(root))


def normalize_pick_text(raw: str) -> Optional[int]:
    m = re.search(r"(\d+)", raw)
    if not m:
        return None
    try:
        return int(m.group(1))
    except ValueError:
        return None


def print_suggestions(query: str, decision: Dict[str, Any], k: Optional[int]) -> None:
    best = decision["recommended"]
    top1_score = decision["top1_score"]
    mode = decision["mode"]
    candidates = decision["candidates"]
    must_show = decision.get("must_show", set())

    print(f"Request: {query}")
    print(f"Mode: {mode} (score={top1_score:.1f})")
    print("Candidates:")
    for i, c in enumerate(candidates, start=1):
        reasons = ",".join(c.get("reasons", [])) or "none"
        suffix = " MUST_SHOW" if c["name"] in must_show else ""
        print(
            f"[{i}] {c['name']}  score={c['score']:.1f}  "
            f"reasons={reasons}{suffix}"
        )

    if decision.get("warn_no_match"):
        print(
            "WARNING: no suitable skill match (barefoot). "
            "Consider rephrasing or using --skill."
        )

    print("PICK_REQUIRED=true")
    if best:
        print(f"RECOMMENDED_SKILL={best}")


def run_full_agent(
    root: Path,
    query: str,
    ranked: List[Dict[str, Any]],
    policy: Dict[str, Any],
    decision: Dict[str, Any],
    stage_gate: bool,
) -> int:
    if not ranked:
        print("MODE=FULL_AGENT")
        print(f"REQUEST={json.dumps(query)}")
        print("RUN=fail")
        print("ERROR=NO_SKILLS_AVAILABLE")
        return 2

    selected = decision.get("recommended") or ranked[0]["name"]
    top1_score = float(decision.get("top1_score", ranked[0]["score"]))
    t_low = float(policy.get("T_low", 15))

    task_name_out = run_checked(
        [str(root / "bin" / "agenthub"), "task-name", "--skill", selected], cwd=root
    ).stdout
    task_name = parse_task_name(task_name_out) or f"{selected}_{utc_compact()}"

    req_rel = write_request_template(root, task_name, query, full_agent=True, skill_name=selected)
    start_cmd = [
        str(root / "bin" / "agenthub"),
        "start",
        "--skill",
        selected,
        "--task-name",
        task_name,
        "--request",
        req_rel,
    ]

    run_cmd = [str(root / "bin" / "agenthub"), "run", "--task", task_name, "--yes"]
    run_env = os.environ.copy()
    run_env["AGENTHUB_STAGE_APPROVAL"] = "yes" if stage_gate else "no"

    started_task = task_name
    start_cp = subprocess.run(start_cmd, cwd=str(root), text=True, capture_output=True)
    if start_cp.returncode == 0:
        started_task = parse_started_task(start_cp.stdout) or task_name
        run_cmd = [str(root / "bin" / "agenthub"), "run", "--task", started_task, "--yes"]

    run_cp = subprocess.CompletedProcess(run_cmd, returncode=1, stdout="", stderr="")
    artifacts = {
        "report": "NONE",
        "result": "NONE",
        "patch": "NONE",
        "staged_dir": "NONE",
    }

    if start_cp.returncode == 0:
        run_cp = subprocess.run(
            run_cmd,
            cwd=str(root),
            text=True,
            capture_output=True,
            stdin=subprocess.DEVNULL,
            env=run_env,
        )
        artifacts = parse_run_artifacts(run_cp.stdout)
        if run_cp.returncode != 0 and artifacts["report"] == "NONE":
            for line in run_cp.stderr.splitlines():
                if line.startswith("SEE="):
                    artifacts["report"] = line.split("=", 1)[1].strip()
                    break

    run_ok = start_cp.returncode == 0 and run_cp.returncode == 0
    outputs = artifacts["result"]
    if outputs == "NONE":
        outputs = artifacts["patch"]

    print("MODE=FULL_AGENT")
    print(f"REQUEST={json.dumps(query)}")
    print(f"CHOSEN_SKILL={selected}")
    print(f"SCORE={top1_score:.1f}")
    if top1_score < t_low:
        print("WARN=NO_GOOD_SKILL_MATCH")
        print("RISK=HIGH")
    print(f"TASK={started_task}")
    print(f"REQUEST_FILE={req_rel}")
    print(f"RUN={'ok' if run_ok else 'fail'}")
    print(f"REPORT={artifacts['report']}")
    print(f"OUTPUTS={outputs}")
    print(f"STAGED_TO_GATE={'yes' if artifacts['staged_dir'] != 'NONE' else 'no'}")

    if run_ok:
        return 0
    if start_cp.returncode != 0:
        msg = (start_cp.stderr or start_cp.stdout or "start failed").strip().splitlines()
        if msg:
            print(f"ERROR={msg[-1]}", file=sys.stderr)
    else:
        msg = (run_cp.stderr or run_cp.stdout or "run failed").strip().splitlines()
        if msg:
            print(f"ERROR={msg[-1]}", file=sys.stderr)
    return 2


def main() -> int:
    root = repo_root()
    parser = argparse.ArgumentParser(
        prog="bart",
        description=(
            "Skill router. Default: route and require explicit pick before "
            "--start/--run."
        ),
    )
    parser.add_argument("request", nargs="*", help="Free-text request. Use quotes.")
    parser.add_argument(
        "--pick",
        default=None,
        help="Candidate index to pick; accepts forms like 1, pick1, candidate3.",
    )
    parser.add_argument("--skill", default=None, help="Explicit skill name.")
    parser.add_argument("--start", action="store_true", help="Start task.")
    parser.add_argument("--run", action="store_true", help="Start (if needed) and run task.")
    parser.add_argument("--yes", action="store_true", help="Forward --yes to agenthub run.")
    parser.add_argument("--no", action="store_true", help="Forward --no to agenthub run.")
    parser.add_argument("--k", type=int, default=None, help="Candidate count override.")
    parser.add_argument(
        "--full-agent",
        action="store_true",
        help="Dangerous autopilot: auto-pick, start, and run without pick confirmation.",
    )
    parser.add_argument(
        "--stage-gate",
        action="store_true",
        help="With --full-agent, auto-stage to GATE when supported.",
    )
    args = parser.parse_args()

    if not args.request:
        parser.print_usage(sys.stderr)
        return 2

    query = " ".join(args.request).strip()
    if not query:
        parser.print_usage(sys.stderr)
        return 2

    if args.full_agent:
        if args.pick is not None or args.skill:
            print("ERROR=--full-agent cannot be combined with --pick/--skill.", file=sys.stderr)
            return 2
    else:
        if args.stage_gate:
            print("ERROR=--stage-gate requires --full-agent.", file=sys.stderr)
            return 2

    if args.k is not None and args.k < 1:
        print("ERROR=--k must be a positive integer.", file=sys.stderr)
        return 2
    if args.yes and args.no:
        print("ERROR=Use only one of --yes or --no.", file=sys.stderr)
        return 2

    if args.pick is not None and args.skill:
        print("ERROR=Use only one of --pick or --skill.", file=sys.stderr)
        return 2

    try:
        ranked = build_ranking(root, query)
        policy = load_json(root / "AGENTS" / "runtime" / "router_policy.json")
        decision = decide_candidates(ranked, policy, args.k)

        if args.full_agent:
            return run_full_agent(root, query, ranked, policy, decision, stage_gate=args.stage_gate)

        if args.pick is None and args.skill is None:
            print_suggestions(query, decision, args.k)
            return 0

        selected = args.skill
        candidates = decision["candidates"]

        if selected is None:
            parsed_pick = normalize_pick_text(str(args.pick))
            if parsed_pick is None:
                print("ERROR=Unable to parse --pick. Use 1, pick1, or candidate3.", file=sys.stderr)
                return 2
            if parsed_pick < 1 or parsed_pick > len(candidates):
                print(f"ERROR=--pick out of range (1..{len(candidates)}).", file=sys.stderr)
                return 2
            selected = candidates[parsed_pick - 1]["name"]

        known = {r["name"] for r in ranked}
        if selected not in known:
            print(f"ERROR=Unknown skill: {selected}", file=sys.stderr)
            return 2

        task_name_out = run_checked(
            [str(root / "bin" / "agenthub"), "task-name", "--skill", selected], cwd=root
        ).stdout
        task_name = parse_task_name(task_name_out)
        if not task_name:
            raise RuntimeError("unable to generate task name")

        req_rel = write_request_template(root, task_name, query, full_agent=False, skill_name=selected)

        print(f"Selected skill: {selected}")
        print(f"Task name: {task_name}")
        print(f"Request template: {req_rel}")
        print(f"SELECTED_SKILL={selected}")
        print(f"TASK_NAME={task_name}")

        start_cmd = [
            str(root / "bin" / "agenthub"),
            "start",
            "--skill",
            selected,
            "--task-name",
            task_name,
            "--request",
            req_rel,
        ]

        if not args.start and not args.run:
            if is_compute_skill(selected):
                start_out = run_checked(start_cmd, cwd=root).stdout.strip()
                if start_out:
                    print(start_out)
                return 0
            print("START_PENDING=true")
            print(f"SELECTED_SKILL={selected}")
            print(f"TASK_NAME={task_name}")
            return 0

        start_out = run_checked(start_cmd, cwd=root).stdout.strip()
        if start_out:
            print(start_out)
        started_task = parse_started_task(start_out) or task_name

        if not args.run:
            if is_compute_skill(selected):
                return 0
            print("STATE=AWAITING_USER_CONFIRMATION")
            print(f"TASK={started_task}")
            print("Run completed setup only. Awaiting explicit user confirmation to execute run.")
            return 0

        if is_compute_skill(selected):
            request_complete = parse_marker(start_out, "REQUEST_COMPLETE").lower()
            if request_complete == "false":
                request_step = parse_marker(start_out, "REQUEST_STEP") or "goal"
                print("STARTED=true")
                print("REQUEST_COMPLETE=false")
                print(f"REQUEST_STEP={request_step}")
                print("STOP_REASON=need_user_input")
                return 0

        run_cmd = [str(root / "bin" / "agenthub"), "run", "--task", started_task]
        if args.yes:
            run_cmd.append("--yes")
        elif args.no:
            run_cmd.append("--no")
        else:
            # Safe default: non-interactive approval mode is --no.
            run_cmd.append("--no")

        sys.stdout.flush()
        cp = subprocess.run(run_cmd, cwd=str(root), text=True)
        return cp.returncode
    except Exception as err:
        msg = str(err).splitlines()[0] if str(err).strip() else err.__class__.__name__
        print(f"ERROR={msg}", file=sys.stderr)
        return 2


if __name__ == "__main__":
    raise SystemExit(main())
